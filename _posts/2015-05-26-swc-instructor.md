---
layout: post
title: "Being a Software Carpentry Instructor"
date: 2015-05-26 20:15:00 -05:00
comments: false
---

Yesterday I finished my Software Carpentry instructor training. This milestone
started me thinking about what to do with this new-found training and this new
peer group to interact with. This required some introspection on why I wanted
to go through the training to begin with.

I thought I knew why when I started and as luck would have it, while reading 
the spring 2015 University of Vermont College of Engineering and Mathmatics
newsletter I found reinforcement on page 26. In the article Forth-Gem CEMS, 
Caitlyn Bishop started as a biochem major, took UVM's intro to Matlab class,
and then decided to switch to major in math with CS and bio minors.

Deep link: http://www.uvm.edu/~cems/cs/?Page=news&storyID=20711&category=cemscs

This was lucky because this is exactly the same experiance I had. This made
it clear to me that lots of people have this transformative experiance with 
programming and computing. entering field "late"....

By the way, by saying I had the exact same experiance, I do mean the (nearly)
the exact same experiance. In the fall of 1994, I was in the very first CS016
Programming for Engineers at UVM. The course is still on the books as CS016 
though it looks like they shifted the focus as it is now called Programming 
MATLAB for Engineers and Science. This was the first time programming made any
sense to me. I managed LOGO in middle school but was lost in BASIC. I was not
ready.

The lecturer for the class was Maggie Eppstien who was still working on her
PhD at the time. She is now the UVM Computer Science department chair. 

I got an A+ (nerd!) and volunteered to be a TA for the class for the next 5
semesters until I graduated. This was the first job that I chose to persue 
myself - no parents involved.



And congratulations to you Caitlyn on being smart enough to switch majors. I 
haven't designed a beam in 20 years and I'm still catching up on basic math
and computer science concepts.


Probably most IT folks are familiar with the "[bus factor](http://en.wikipedia.org/wiki/Bus_factor)"
or "the lottery factor" if you prefer to think of good things happening to your
coworkers. It's the number of people who can get hit by a bus (or retire to a 
Carribean Island) before a project is doomed because no one knows how anything
works.

The question is, what is a good bus factor? For really small projects it's 
simply going to be 1 and that is just the way it is. Hiring two people who both
have complete knowlege of one job is just too expensive and the project simply
won't happen. For a larger project, how do you know whether 3 or 5 or 10 is 
appropriate?

Enter the **Bus Factor Valuation Formula**:

[![actual value = desired value * (1 - 1/bus factor)](/images/bus_factor_valuation_eq.png)](http://arachnoid.com/latex/?equ=%5Ctext%7Bactual%20value%7D%20%3D%20%5Ctext%7Bdesired%20value%7D%5Ctimes(1%20-%20%5Cfrac%7B1%7D%7Bbus%20factor%7D)%0A)

From a graph of that last term you can see that this is a pretty harsh 
function for small teams:

[![Bus Factor Valuation graph](/images/bus_factor_valuation_graph.png)]
(https://www.desmos.com/calculator)

If only one person knows how everything works, your project is worth nothing.
Even with 2 people knowing how your project works, your project is really
only worth half of what you want it to be. Past 4 or 5 people the value 
flattens out fast. If you want to get more than 80% of what you think your
project is worth, you need to start thinking about redundant teams, not
redundant people.

I won't make any statements about the fact that this equation imples every
project is [worth less than anyone thinks it is](http://finance.yahoo.com/echarts?s=^NDX+Interactive#{"range"%3A"max"%2C"scale"%3A"linear"}).

Here is my coworkers' take on this idea:

![Bus Factor Whiteboard](/images/bus_factor_whiteboard.jpg)

